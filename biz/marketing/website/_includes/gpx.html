{% assign gpxfilename = include.gpxfilename %}
{% assign gpxfilename2 = include.gpxfilename2 %}
{% assign random_number = "now" | date: "%s%N" | modulo: 1000 %}


<script>
if (!document.querySelector('script[src="/biz/marketing/website/assets/js/vendor/GPXParser-3.1.0.js"]')) {
    var script = document.createElement('script');
    script.src = "/biz/marketing/website/assets/js/vendor/GPXParser-3.1.0.js";
    document.head.appendChild(script);
}

</script>
<script src="https://cdn.jsdelivr.net/npm/simplify-js@1.2.4/simplify.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<!-- Example placeholder for the Plotly chart -->
<div id="plotlyChart{{random_number}}" style="width:100%;height:256px;"></div>




<script>
document.addEventListener("DOMContentLoaded", function() {
  // Constants
  const timeZone = 'Europe/Berlin';
  const gpxFileName = '{{gpxfilename2}}';
  const plotlyChartId = 'plotlyChart{{ random_number }}';
  
  // Initialize GPX Parser
  let gpx = new gpxParser();

  // Fetch and process the GPX file
  fetch(gpxFileName)
    .then(response => response.text())
    .then(gpxText => {
      try {
        gpx.parse(gpxText);

        console.log("Parsed GPX object:", gpx);

        if (gpx && gpx.tracks.length > 0) {
          let elevationPoints = [];
          let annotations = [];
          let markerPoints = [];
          let nutritionPoints = [];
          let undulatingStartPoints = [];
          let undulatingEndPoints = [];
          let track = gpx.tracks[0]; // Assume the first track

          // Process trackpoints for elevation data and annotations
          track.points.forEach((point, index) => {
            if (point.ele !== undefined) {
              let date = new Date(point.time);
              date = new Date(date.toLocaleString('en-US', { timeZone: timeZone }));
              elevationPoints.push({ x: date.getTime(), y: point.ele });

              if (point.extensions) {
                if (point.extensions.TerrainAnalysis) {
                  let terrainAnalysis = point.extensions.TerrainAnalysis;
                  let isBottomOfAscend = terrainAnalysis.isBottomOfAscend === 'true';
                  let isPeakOfAscend = terrainAnalysis.isPeakOfAscend === 'true';
                  let elevationDelta = terrainAnalysis.ElevationDelta;
                  let isBeginOfUndulatingTerrain = terrainAnalysis.isBeginOfUndulatingTerrain === 'true';
                  let isEndOfUndulatingTerrain = terrainAnalysis.isEndOfUndulatingTerrain === 'true';
                  let cumulativeElevationGain = terrainAnalysis.CumulativeElevationGain;

                  if (isBottomOfAscend) {
                    markerPoints.push({ x: date.getTime(), y: point.ele });
                  }

                  if (isPeakOfAscend && elevationDelta) {
                    annotations.push({
                      x: date.getTime(),
                      y: point.ele,
                      text: `Δ ${elevationDelta} m`,
                      showarrow: true,
                      arrowhead: 2,
                      ax: 0,
                      ay: -50,
                      yshift: 10,
                    });
                  }

                  if (isBeginOfUndulatingTerrain) {
                    undulatingStartPoints.push({ x: date.getTime(), y: point.ele });
                  }

                  if (isEndOfUndulatingTerrain && cumulativeElevationGain) {
                    undulatingEndPoints.push({
                      x: date.getTime(),
                      y: point.ele,
                      text: `Σ ${cumulativeElevationGain} m`,
                      showarrow: true,
                      arrowhead: 2,
                      ax: 0,
                      ay: -50,
                      yshift: 10,
                    });
                  }
                }
              }
            }
          });

          // Process waypoints for nutrition stops and other markers
          gpx.waypoints.forEach((waypoint, index) => {
            if (waypoint.name.includes("Nutrition")) {
              let date = new Date(waypoint.time);
              date = new Date(date.toLocaleString('en-US', { timeZone: timeZone }));
              nutritionPoints.push({ x: date.getTime(), y: 20 }); // Adjusted for visibility
            }
          });

          // Debug output
          console.log("Total Bottom of Ascend markers:", markerPoints.length);
          console.log("Total Peak of Ascend annotations:", annotations.length);
          console.log("Total Nutrition:", nutritionPoints.length);
          console.log("Total Begin of Undulating Terrain markers:", undulatingStartPoints.length);
          console.log("Total End of Undulating Terrain markers:", undulatingEndPoints.length);

          // Plotly traces and layout
          const trace = {
            x: elevationPoints.map(p => new Date(p.x)),
            y: elevationPoints.map(p => p.y),
            type: 'scatter',
            mode: 'lines',
            fill: 'tozeroy',
            fillcolor: 'rgba(147, 161, 161, 0.3)',
            line: {
              color: '#268bd2',
              width: 1.5,
            },
            name: 'Elevation (m)',
          };

          const markerTrace = {
            x: markerPoints.map(p => new Date(p.x)),
            y: markerPoints.map(p => p.y),
            type: 'scatter',
            mode: 'markers',
            marker: {
              color: '#b58900',
              size: 8,
              symbol: 'circle',
            },
            name: 'Bottom of Ascend',
          };

          const peakTrace = {
            x: annotations.map(a => new Date(a.x)),
            y: annotations.map(a => a.y),
            mode: 'markers',
            marker: {
              color: '#268bd2',
              size: 8,
              symbol: 'circle',
            },
            showlegend: true,
            name: 'Peak of Ascend',
          };

          const undulatingStartTrace = {
            x: undulatingStartPoints.map(p => new Date(p.x)),
            y: undulatingStartPoints.map(p => p.y),
            type: 'scatter',
            mode: 'markers',
            marker: {
              color: '#cb4b16',  // Solarized orange
              size: 8,
              symbol: 'circle',
            },
            showlegend: true,
            name: 'Begin of Undulating Terrain',
          };

          const undulatingEndTrace = {
            x: undulatingEndPoints.map(a => new Date(a.x)),
            y: undulatingEndPoints.map(a => a.y),
            mode: 'markers',
            marker: {
              color: '#6c71c4',  // Solarized violet
              size: 8,
              symbol: 'circle',
            },
            showlegend: true,
            name: 'End of Undulating Terrain',
          };

          const nutritionTrace = {
            x: nutritionPoints.map(p => new Date(p.x)),
            y: nutritionPoints.map(p => p.y),
            mode: 'markers',
            marker: {
              color: '#2aa198',
              size: 8,
              symbol: 'diamond',
            },
            name: 'Nutrition',
          };

          const layout = {
            title: 'Elevation over Time (Preprocessed)',
            xaxis: {
              //title: 'Time (24h format)',
              color: '#586e75',
              tickcolor: '#657b83',
            },
            yaxis: {
              title: 'Elevation (m)',
              color: '#586e75',
              tickcolor: '#657b83',
              showgrid: false,
            },
            plot_bgcolor: '#fdf6e3',
            paper_bgcolor: '#fdf6e3',
            margin: {
              l: 80,
              r: 50,
              b: 80,
              t: 40,
              pad: 10,
            },
            showlegend: true,
            annotations: annotations.concat(undulatingEndPoints), // Combine peak and undulating annotations
          };

          // Plot the graph
          Plotly.newPlot(plotlyChartId, [trace, markerTrace, peakTrace, undulatingStartTrace, undulatingEndTrace, nutritionTrace], layout);
        } else {
          console.error("No valid tracks or points found in the GPX file.");
        }
      } catch (error) {
        console.error("An error occurred during GPX parsing:", error);
      }
    })
    .catch(error => console.error("Error loading GPX file:", error));
});
</script>








